# Agent Workflow

This document captures the high-level steps for extending RivetBench in an interface-first, BDD-oriented manner.

## üóÇÔ∏è Temporary Files Management

**All temporary files should go in `.agent/` directory** (gitignored):
- `.agent/memory/` - Context tracking, agent state, session notes
- `.agent/pr/` - PR descriptions, instructions, draft content  
- `.agent/summaries/` - Implementation summaries, cleanup logs

See `.agent/README.md` for full details.

## Core Principle

**The goal of all changes is to create a Pull Request.** Every feature, refactor, or improvement should result in a PR that can be reviewed and merged into the main branch. Work should be organized into logical, reviewable units.

## Development Steps

1. **Create a feature branch** ‚Äì Always start from an up-to-date main branch. Use descriptive branch names following conventions in `CONTRIBUTING.md`.

2. **Clarify behavior** ‚Äì Capture the desired capability in a `.feature` file under `test/features/` using Gherkin syntax.

3. **Design the interface** ‚Äì Define or update TypeScript interfaces and schemas inside `src/core` or `src/endpoints` without touching the concrete implementation.

4. **Add scaffolding** ‚Äì Extend registries, configuration, or server wiring to expose the new interface surface.

5. **Implement handlers** ‚Äì Only after the interface is stable, fill in concrete behavior and validation logic.

6. **Automate checks** ‚Äì Add or update Vitest/Cucumber step definitions to exercise the new behavior as soon as it's implemented.

7. **Document changes** ‚Äì Update relevant documentation (README.md, docs/, etc.) to reflect new capabilities.

8. **Commit regularly** ‚Äì Make atomic commits with clear, conventional commit messages. Ensure all files are committed before creating the PR.

9. **Create Pull Request** ‚Äì Push your branch and create a PR with a clear description of changes, benefits, and testing performed. The PR is the deliverable.

## Architecture Guidelines

### Transport Parity

**All transports (REST, MCP, etc.) must maintain behavioral consistency:**

1. **Request ID Propagation** ‚Äì Every transport must generate and propagate a unique request ID via `config.requestId` to endpoint handlers
   - Use `crypto.randomUUID()` for RFC 4122 compliance for application-level tracing
   - REST: Auto-generated by Fastify and returned in `x-request-id` header
   - MCP: Generated per tool execution (FastMCP doesn't expose JSON-RPC IDs)
   - Include request ID in error logs for traceability
   - Document in ERROR_HANDLING.md if transport-specific behavior exists

2. **Schema Validation** ‚Äì All transports must validate input/output using the same Zod schemas defined in endpoints

3. **Error Handling** ‚Äì All transports must convert errors to RivetBenchError format for consistent client experience

4. **Observability** ‚Äì All transports must support request tracing, logging, and debugging through consistent context propagation

**Testing Transport Parity:**
- Add regression tests for any cross-transport contract (see `test/server/request-id-parity.test.ts`)
- Test that handlers receive identical context structure across transports
- Verify edge cases (errors, validation failures) behave consistently

```
